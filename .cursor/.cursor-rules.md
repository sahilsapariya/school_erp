You are working inside an existing School ERP codebase.
You MUST strictly follow the existing coding standards and patterns.

========================
GENERAL RULES
========================

1. DO NOT invent new architecture.
2. DO NOT invent new patterns.
3. DO NOT invent new abstractions.
4. First ANALYZE existing code, then MODIFY.
5. Consistency is more important than cleverness.
6. Prefer simple, explicit code.
7. No magic, no shortcuts.

========================
BACKEND RULES (FLASK)
========================

Project uses:
- Flask
- SQLAlchemy
- JWT authentication
- RBAC via permissions
- Modular architecture

MANDATORY BACKEND PATTERNS:

1. Routes must be THIN
   - Routes only:
     - read request data
     - call service functions
     - return response

2. Business logic MUST live in services
   - No business logic in routes
   - No DB logic in routes

3. RBAC:
   - Authorization ONLY via permission decorators
   - NEVER check role names directly
   - NEVER hardcode role names
   - Permissions follow: resource.action.scope

4. Validation:
   - Follow same validation approach used in auth / rbac modules
   - Validation errors must return clear messages
   - No silent failures

5. Models:
   - SQLAlchemy models only
   - No business logic inside models
   - Relationships must be explicit

6. Error handling:
   - Use existing error/response helpers
   - Do NOT introduce new error formats

7. Naming:
   - snake_case for functions & variables
   - Singular resource names (student, class, attendance)
   - Keep naming consistent with existing modules

8. Transactions:
   - Ensure DB commits are safe
   - Rollback on failure

========================
FRONTEND RULES
========================

Project uses:
- Modular frontend structure
- app/ for routing
- modules/ for business logic
- common/ for shared utilities

MANDATORY FRONTEND PATTERNS:

1. Screens must be THIN
   - No API calls in screens
   - No business logic in screens

2. Data flow:
   Screen → Hook → Service → API

3. Services:
   - All API calls live in services
   - Use existing API client
   - No direct fetch/axios in components

4. Hooks:
   - Handle loading, error, success
   - No UI rendering inside hooks

5. Components:
   - Pure UI
   - No API calls
   - No permission checks unless UI-specific

6. Permissions:
   - UI hides elements based on permissions
   - Backend is the source of truth
   - Never assume permission on frontend

7. State:
   - Follow existing state management approach
   - No ad-hoc global state

========================
SCOPE CONTROL
========================

1. If a field, API, or feature does NOT already exist:
   - DO NOT add it unless explicitly asked.

2. If unsure:
   - ASK or clearly state assumptions.

3. No feature creep.
4. No speculative changes.

========================
OUTPUT EXPECTATION
========================

- Code must look like it was written by the same developer who wrote auth and rbac modules.
- Refactors must be minimal and safe.
- Explain changes briefly and clearly.
